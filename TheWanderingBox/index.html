<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Wandering Box</title>
    <style>
        .exitGate {
            position: absolute;
            left: 95%;
            width: 25px;
            height: 25px;
            margin: 0px;
            padding: 10px;
            text-align: center;
            border: 2px solid white;
            border-radius: 5px;
            z-index: 3;
        }
        .exitGate:hover {
            border: 2px solid red;
        }
        .exitGate a {
            text-decoration: none;
            color: white;
            font-family: 'Courier New', monospace;
            font-size: 25px;
        }
        .exitGate:hover a:hover {
            color: red;
        }
        body {
            background-color: black;
            color: white;
        }

        canvas {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: grey;
            border: 10px solid grey;
        }
    </style>
</head>
<body>
    <div class="exitGate"><a href="../index.html">X</a></div>
    <canvas id="layoutRender" width="1200" height="600"></canvas>
    <script>
        const startAnimation = () => {
            const layoutRender = document.getElementById("layoutRender");

            class Box {
                constructor(arraySys) {
                    this.pos = this.randomPosition(arraySys);

                    this.dir = {
                        w : {x: 0, y: -1},
                        q : {x: -1, y: -1},
                        a : {x: -1, y: 0},
                        z : {x: -1, y: 1},
                        x : {x: 0, y: 1},
                        c : {x: 1, y: 1},
                        d : {x: 1, y: 0},
                        e : {x: 1, y: -1}
                    };
                }

                move(stringVar) {
                    const {x,y} = this.dir[stringVar];
                    this.pos = {
                        x : this.pos.x + x,
                        y : this.pos.y + y
                    };
                }

                randomPosition(arraySys) {
                    let pos;
                    pos = {
                        x : Math.floor(Math.random() * arraySys[0].length),
                        y : Math.floor(Math.random() * arraySys.length)
                    }

                    return pos;
                }
            }

            class Environment {
                constructor() {
                    this.box = {
                        width: 10,
                        height: 10
                    };

                    this.arrSys = this.createLayout();

                    this.callBox = new Box(this.arrSys);
                    this.arrSys[this.callBox.pos.y][this.callBox.pos.x] = 1;

                    this.trackBox = { ...this.callBox.pos };

                    this.fin = this.randomFreePosition();
                    this.arrSys[this.fin.y][this.fin.x] = 2;

                    this.dirtyObject = [];
                }

                createLayout() {
                    const width = layoutRender.width/this.box.width;
                    const height = layoutRender.height/this.box.height;

                    return Array.from({length: height}, () => Array(width).fill(0));
                }

                randomFreePosition() {
                    let pos;
                    do {
                        pos = {
                            x : Math.floor(Math.random() * this.arrSys[0].length),
                            y : Math.floor(Math.random() * this.arrSys.length)
                        }
                    } while (this.arrSys[pos.y][pos.x] === 1);

                    return pos;
                }

                mazeFindPath() {
                    const width = layoutRender.width/this.box.width;
                    const height = layoutRender.height/this.box.height;

                    const ans = [];
                    const visited = Array.from({ length: height }, () => Array(width).fill(false));
                    const queue = [];

                    queue.push(
                        {
                            x : this.callBox.pos.x,
                            y : this.callBox.pos.y,
                            move : ""
                        }
                    );
                    visited[this.callBox.pos.y][this.callBox.pos.x] = true;

                    while (queue.length > 0) {
                        queue.sort((a,b) => a.move.length - b.move.length);

                        const { x : currX, y : currY, move : currMove } = queue.shift();

                        if (currX === this.fin.x && currY === this.fin.y) {
                            ans.push(currMove);
                            break;
                        }

                        for (const [key,value] of Object.entries(this.callBox.dir)) {
                            const nextX = currX + value.x;
                            const nextY = currY + value.y;
                            const nextMove = currMove + key;

                            if ((nextX >= 0 && nextX < width && nextY >= 0 && nextY < height) && (this.arrSys[nextY][nextX] === 0 || this.arrSys[nextY][nextX] === 1 || this.arrSys[nextY][nextX] === 2) && visited[nextY][nextX] == false) {
                                visited[nextY][nextX] = true;
                                queue.push(
                                    {
                                        x : nextX,
                                        y : nextY,
                                        move : nextMove
                                    }
                                );
                            }
                        }
                    }

                    return ans;
                }

                animationCreation() {
                    let current = 0;
                    const stringEvent = this.mazeFindPath()[0];
                    const animateBox = () => {
                        if (current < stringEvent.length) {
                            const e = stringEvent[current];
                            this.callBox.move(e);
                            this.detectBox();
                            this.reLayout();
                            current++;
                            requestAnimationFrame(animateBox);
                        } else {
                            this.resetFinish();
                            requestAnimationFrame(this.animationCreation.bind(this));
                        }
                    }

                    animateBox();
                }

                detectBox() {
                    this.dirtyObject = [];

                    const { x : trackX, y : trackY} = this.trackBox;
                    this.arrSys[trackY][trackX] = 0;
                    this.dirtyObject.push({
                        x : trackX,
                        y : trackY,
                        color : 0
                    });

                    const { x , y } = this.callBox.pos;

                    if (x < 0 || x > this.arrSys[0].length - 1 || y < 0 || y > this.arrSys.length - 1) {
                        this.arrSys[trackY][trackX] = 1;

                        this.callBox.pos = { x : trackX, y : trackY};
                        this.dirtyObject.push({
                            x : this.callBox.pos.x,
                            y : this.callBox.pos.y,
                            color : 1
                        });
                        return;
                    }

                    if (this.arrSys[y][x] === 0 || this.arrSys[y][x] === 2) {
                        this.arrSys[y][x] = 1;

                        this.trackBox = {x,y};
                        this.dirtyObject.push({
                            x : this.callBox.pos.x,
                            y : this.callBox.pos.y,
                            color : 1
                        });
                        return;
                    }
                }

                layout() {
                    const draw = layoutRender.getContext("2d");
                    draw.clearRect(0, 0, layoutRender.width, layoutRender.height);

                    for (let i = 0; i < this.arrSys.length; i++) {
                        for (let j = 0; j < this.arrSys[i].length; j++) {
                            draw.fillStyle = this.getCellColor(this.arrSys[i][j]);
                            draw.fillRect(j * this.box.width, i * this.box.height, this.box.width, this.box.height);
                        }
                    }
                }

                reLayout() {
                    const draw = layoutRender.getContext("2d");

                    this.dirtyObject.forEach(obj => {
                        draw.fillStyle = this.getCellColor(obj.color);
                        draw.fillRect(obj.x * this.box.width, obj.y * this.box.height, this.box.width, this.box.height);
                    });
                }

                getCellColor(cellVal) {
                    switch (cellVal) {
                        case 0:
                            return "black";
                        
                        case 1:
                            return "red";
                    
                        default:
                            return "black";
                    }
                }

                resetFinish() {
                    this.fin = this.randomFreePosition();
                    this.arrSys[this.fin.y][this.fin.x] = 2;
                    this.trackBox = { ...this.callBox.pos };
                    this.arrSys[this.callBox.pos.y][this.callBox.pos.x] = 1;
                    this.layout();
                }
            }

            const renderEnv = new Environment();
            renderEnv.layout();
            renderEnv.animationCreation();
        }

        startAnimation();
    </script>
</body>
</html>